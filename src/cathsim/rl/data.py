from pathlib import Path
from typing import Union
import pickle
import numpy as np
import gymnasium as gym
from stable_baselines3.common.base_class import BaseAlgorithm

import torch
from torch.utils import data
import pprint
from toolz.dicttoolz import itemmap
from functools import reduce
from cathsim.dm.visualization import plot_3D_to_2D
from cathsim.dm.utils import flatten_dict, expand_dict, map_val

import matplotlib.pyplot as plt
from tqdm import tqdm

RESULTS_PATH = Path.cwd() / "results"


class Trajectory:
    """A trajectory object. Stores a trajectory as a dictionary of numpy arrays.

    This class is used to store trajectories in a structured way. It is used to store
    trajectories in the CathSim environment, and can be used to store trajectories
    generated by a policy.

    It contains useful methods for manipulating the data, such as flattening the
    dictionary, converting all values to numpy arrays, and applying a function to
    all values.

    Args:
        image_size (int): Size of the image. Used for converting 3D points to 2D

    Note:
        If keys are not provided in the constructor, they will be inferred from the
        keyword arguments when adding a transition.

    Example:
        >>> traj = Trajectory()
        >>> traj.add_transition(obs=obs, act=act, next_obs=next_obs, reward=reward, info=info)
        >>> traj.flatten()
        >>> traj.to_array()
        >>> traj.save("path/to/file.pkl")
        >>> traj = Trajectory.load("path/to/file.pkl")
    """

    def __init__(
        self,
        image_size: int = None,
        **kwargs,
    ):
        self.data = kwargs or self._initialize(kwargs)
        self.image_size = image_size

    def __str__(self):
        """Returns a string representation of the trajectory"""

        def fn(item):
            k, v = item
            if isinstance(v, dict):
                return (k, itemmap(fn, v))
            else:
                return (k, v.shape if isinstance(v, np.ndarray) else np.array(v).shape)

        return pprint.pformat(itemmap(fn, self.data))

    def __len__(self):
        """Returns the length of the trajectory"""

        def fn(d: dict):
            for k, v in d.items():
                if isinstance(v, dict):
                    fn(v)
                else:
                    return len(v)

        return fn(self.data)

    def __getitem__(self, index: Union[int, str]):
        """Gets either a transition or a key from the trajectory

        Args:
            index (Union[int, str]): The index or key to get

        Raises:
            TypeError: If the index is not an int or a string

        Returns:
            Union[dict, np.ndarray]: The transition or key

        Example:
            >>> traj = Trajectory()
            >>> traj.add_transition(obs=obs, act=act, next_obs=next_obs, reward=reward, info=info)
            >>> traj[0]
            {'obs': array([0.1, 0.2, 0.3]), 'act': array([0.1, 0.2, 0.3]), 'next_obs': array([0.1, 0.2, 0.3]), 'reward': 0.1, 'info': {'success': True}}
            >>> traj["obs"]
            array([[0.1, 0.2, 0.3],
        """
        if isinstance(index, int):
            return map_val(lambda x: x[index], self.data)
        elif isinstance(index, str):

            def fn(acc, item):
                k, v = item
                if isinstance(v, dict):
                    new_items = reduce(fn, v.items(), {})
                    acc.update(new_items)
                elif isinstance(k, str) and index in k:
                    acc[k] = v
                return acc

            return reduce(fn, self.data.items(), {})

        else:
            raise TypeError("Invalid Argument Type")

    def get_k_len(self, key: str = None):
        """Gets the length of a key in the trajectory

        Gets the length of a key in the trajectory. This is useful for checking if
        the trajectory has uneven lengths. For example, if the trajectory has a
        final observation stored, it will have a different length than the other
        keys.

        Args:
            key (str): The key to get the length of

        Returns:
            int: The length of the key
        """

        def fn(d: dict):
            for k, v in d.items():
                if isinstance(v, dict):
                    fn(v)
                else:
                    if k == key:
                        return len(v)

        return fn(self.data)

    def _initialize(self, d: dict):
        """Initializes the trajectory

        Args:
            d (dict): The dictionary to initialize the trajectory with
        """
        self.data = map_val(lambda x: [], d)

    def _validate(self):
        """Validates the trajectory

        Checks if the trajectory has uneven lengths. If a final observation is stored,
        it will have a different length than the other keys. This is not allowed.
        """

        def fn(acc, item):
            k, v = item
            if isinstance(v, dict):
                return all(fn(acc, sub_item) for sub_item in v.items())
            else:
                return len(v) if acc is None else len(v) == acc

        valid = reduce(fn, self.data.items(), len(self))
        if not valid:
            print(
                f"""Trajectory has uneven lengths. 
        If a final obs is stored, please remove it or create a new obs using 
        Trajectory.make_next_obs().
                   """
            )
            exit()
        return self

    @staticmethod
    def from_dict(data: dict):
        """Creates a trajectory from a dictionary

        Args:
            data (dict): The dictionary to create the trajectory from
        """
        obj = Trajectory()
        obj.data = data
        return obj

    def to_array(self):
        """Makes all values in the trajectory numpy array"""
        self.data = map_val(
            lambda x: x if isinstance(x, np.ndarray) else np.array(x), self.data
        )
        return self

    def add_transition(self, **kwargs):
        """Adds a transition to the trajectory

        Adds a transition to the trajectory. The transition is added to all keys
        in the trajectory. If a key is not provided, it is initialized to an empty
        list.
        """
        if self.data is None:
            self._initialize(kwargs)
        self.data = expand_dict(self.data, kwargs)

    def flatten(self):
        """Flattens the trajectory

        Flattens the trajectory. This simplifies the trajectory by removing the
        nested structure. This is useful for preforming operations on the trajectory.
        """
        self.data = flatten_dict(self.data)
        return self

    def apply(self, fn: callable, key: str = None):
        """High order function to apply a function to all values in the trajectory

        This function applies a function to all values in the trajectory. If a key
        is provided, the function is only applied to that key.

        Args:
            fn (callable): The function to apply
            key (str): The key to apply the function to
        """

        def gn(item):
            k, v = item
            if isinstance(v, dict):
                return (k, itemmap(gn, v))
            else:
                if key is None:
                    return (k, fn(v))
                else:
                    return (k, fn(v) if k == key else v)

        self.data = itemmap(gn, self.data)

        return self

    def save(self, file_path: Union[str, Path]):
        """Saves the trajectory to a file

        Saves the trajectory to a file. The file is saved as a pickle file.

        Args:
            file_path (Union[str, Path]): The path to save the file to or the file name
        """
        if not file_path.parent.exists():
            file_path.parent.mkdir()
        if not file_path.suffix == ".pkl":
            file_path = file_path.with_suffix(".pkl")
        with open(file_path, "wb") as file:
            pickle.dump(self.data, file)

    @staticmethod
    def load(file_path: Union[str, Path]):
        """Loads a trajectory from a file

        Loads a trajectory from a file. The file is loaded as a pickle file.

        Args:
            file_path (Union[str, Path]): The path to load the file from or the file name
        """
        if not file_path.suffix == ".pkl":
            file_path = file_path.with_suffix(".pkl")
        with open(file_path, "rb") as file:
            data = pickle.load(file)
        return Trajectory.from_dict(data)

    def plot_path(
        self,
        ax: plt.Axes = None,
        key: str = None,
        plot_kwargs: dict = dict(
            base_image=None,
            add_line=True,
            line_kwargs={},
            scatter_kwargs={},
        ),
    ):
        """Plots a path from the trajectory

        Plots a path from the trajectory. The path is plotted on a 2D image. The
        image size is determined by the image_size attribute of the trajectory.

        Args:
            ax (plt.Axes): The axes to plot on
            key (str): Key to plot. If None, the head_pos key is used
            plot_kwargs (dict): Additional keyword arguments to pass to the plot function
        """
        data = list(self[key or "head_pos"].values())
        plot_3D_to_2D(ax, *data, **plot_kwargs)


class TrajectoriesDataset(data.Dataset):
    def __init__(self, path: Path, transform_image=None, lazy_load=True):
        self.trajectories = list(path.iterdir())
        self.lazy_load = lazy_load
        if not lazy_load:
            self.trajectories = [
                Trajectory.load(p).to_array()["head_pos"] for p in self.trajectories
            ]

    def __len__(self):
        return len(self.trajectories)

    @staticmethod
    def patch_trajectory(traj: np.ndarray, length: int = 300) -> np.ndarray:
        shape = traj.shape
        shape = (length - len(traj), shape[1])
        return np.concatenate([traj, np.zeros(shape=shape)], axis=0)

    def __getitem__(self, idx):
        # TODO: fix the lazy loading
        if self.lazy_load:
            trajectory = Trajectory.load(self.trajectories[idx]).to_array()
        trajectory = self.trajectories[idx]["head_pos"]
        start = trajectory[0]
        goal = trajectory[-1]
        trajectory = self.patch_trajectory(trajectory)

        start = torch.from_numpy(start).float()
        goal = torch.from_numpy(goal).float()
        trajectory = torch.from_numpy(trajectory).float()

        return (start, goal), trajectory


def generate_trajectory(model: BaseAlgorithm, env: gym.Env) -> Trajectory:
    """Utility function to generate a trajectory from a model and environment

    Args:
        model (BaseAlgorithm): The model to generate the trajectory from
        env (gym.Env): The environment to generate the trajectory in
        n_episodes (int): Number of episodes to generate

    Returns:
        Trajectory: The generated trajectory
    """
    trajectory = Trajectory()
    obs = env.reset()
    done = False
    while not done:
        act, _states = model.predict(obs)
        next_obs, reward, done, info = env.step(act)
        trajectory.add_transition(
            obs=obs, act=act, next_obs=next_obs, reward=reward, info=info
        )
        obs = next_obs
    return trajectory


def generate_trajectories(algorithm_path: Path, n_episodes: int = 10_000):
    """Generate multiple trajectories from a trained model

    Args:
        algorithm_path (Path): Path to the trained model
        n_episodes (int): number of episodes to generate
    """
    from stable_baselines3 import SAC
    from cathsim.rl.utils import Config, generate_experiment_paths
    from cathsim.utils import make_gym_env

    model_path, _, eval_path = generate_experiment_paths(
        algorithm_path,
        base_path=Path.cwd() / Path("results/experiments/"),
    )
    print(model_path)

    for model_filename in model_path.iterdir():
        model_name = model_filename.stem
        print(f"Evaluating {model_name} in {algorithm_path} for {n_episodes} episodes.")
        config = Config(algorithm_path.stem)
        config["task_kwargs"]["phantom"] = algorithm_path.parent.parent.stem
        config["task_kwargs"]["target"] = algorithm_path.parent.stem
        algo_kwargs = config["algo_kwargs"]
        env = make_gym_env(config)
        model = SAC.load(
            model_filename,
            custom_objects={"policy_kwargs": algo_kwargs.get("policy_kwargs", {})},
        )

        for n in tqdm(range(n_episodes)):
            trajectory = generate_trajectory(model, env)
            trajectory.save(Path(f"transitions_bodies-full/{n}"))


if __name__ == "__main__":
    generate_trajectories(Path("phantom3/bca/full"))
    exit()
    path = Path.cwd() / Path("transitions-shape/")
    trajectories = list(path.iterdir())
    traj_1 = Trajectory.load(trajectories[0]).to_array()
    print(traj_1)
    # print(len(traj_1))
    # print(traj_1.flatten())
    # print(traj_1)
    # traj_1 = traj_1.apply(lambda x: np.array(x))
    # print(traj_1.data["info"][0])
    # print(traj_1)
    td = TrajectoriesDataset(path, lazy_load=False)
    td_loader = data.DataLoader(td, batch_size=2)
    (start, goal), path = next(iter(td_loader))
